import * as Misskey from 'misskey-js';
import Database from 'better-sqlite3';
import fs from 'fs';
import pkg from 'ws';

// WebSocketã®ãƒãƒªãƒ•ã‚£ãƒ«ï¼ˆNode.jsç’°å¢ƒç”¨ï¼‰
const WebSocket = pkg.WebSocket || pkg.default || pkg;
global.WebSocket = WebSocket;

const MISSKEY_URL = process. env.MISSKEY_URL;
const MISSKEY_TOKEN = process.env.MISSKEY_TOKEN;

// 1. ç’°å¢ƒå¤‰æ•°ãƒã‚§ãƒƒã‚¯ï¼ˆå¿…é ˆï¼ï¼‰
if (!MISSKEY_URL || !MISSKEY_TOKEN) {
  console.error('Error: MISSKEY_URL and MISSKEY_TOKEN must be set in . env file');
  process.exit(1);
}

// 2. BotãŒã„ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ›ã‚¹ãƒˆåã‚’å–å¾—
const BOT_HOST = new URL(MISSKEY_URL).hostname;
console.log(`Bot instance host: ${BOT_HOST}`);

// 3. dataãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒãªã‘ã‚Œã°ä½œæˆï¼ˆå†å¸°çš„ã«ä½œæˆï¼‰
if (!fs.existsSync('./data')) {
  try {
    fs.mkdirSync('./data', { recursive: true });
    console.log('Created ./data directory');
  } catch (err) {
    console.error('Failed to create data directory:', err);
    process.exit(1);
  }
}

// Misskeyæ¥ç¶š
const cli = new Misskey.api.APIClient({
  origin: MISSKEY_URL,
  credential: MISSKEY_TOKEN,
});

const stream = new Misskey.Stream(MISSKEY_URL, {
  token: MISSKEY_TOKEN,
});

// Botè‡ªèº«ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼IDå–å¾—
let botUserId;
cli.request('i').then((res) => {
  botUserId = res.id;
  console.log(`Bot user ID: ${botUserId}`);
}).catch(err => {
  console.error('Login failed.  Check your Token. ', err);
  process.exit(1);
});

// SQLiteãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–
const db = new Database('./data/database.db');
db.exec(`
  CREATE TABLE IF NOT EXISTS logbo_records (
    user_id TEXT PRIMARY KEY,
    username TEXT,
    total_days INTEGER DEFAULT 0,
    consecutive_days INTEGER DEFAULT 0,
    last_logbo_date TEXT
  )
`);

// JSTæœ5æ™‚åŸºæº–ã®æ—¥ä»˜ã‚’å–å¾—
function getLogboDate() {
  const now = new Date();
  const jstOffset = 9 * 60 * 60 * 1000;
  const jstTime = new Date(now.getTime() + jstOffset);
  jstTime.setHours(jstTime.getHours() - 5);
  return jstTime.toISOString().split('T')[0];
}

// ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
async function isFollower(userId) {
  try {
    const relation = await cli.request('users/relation', { userId: [userId] });
    return relation[0]?.isFollowing || false;
  } catch (error) {
    console.error('Failed to check follower status:', error);
    return false;
  }
}

// ãƒ•ã‚©ãƒ­ãƒ¼æ©Ÿèƒ½
async function followUser(userId) {
  try {
    await cli.request('following/create', { userId });
    console.log(`Followed user:  ${userId}`);
  } catch (error) {
    console.error('Failed to follow user:', error);
  }
}

// ãƒ­ã‚°ãƒœè¨˜éŒ²å‡¦ç†
function recordLogbo(userId, fullAcct) {
  const today = getLogboDate();

  const record = db.prepare('SELECT * FROM logbo_records WHERE user_id = ?').get(userId);

  if (!record) {
    db.prepare('INSERT INTO logbo_records (user_id, username, total_days, consecutive_days, last_logbo_date) VALUES (?, ?, 1, 1, ?)').run(userId, fullAcct, today);
    return { total:  1, consecutive: 1, alreadyDone: false };
  }
  
  if (record.last_logbo_date === today) {
    if (record.username !== fullAcct) {
      db.prepare('UPDATE logbo_records SET username = ?  WHERE user_id = ?').run(fullAcct, userId);
    }
    return { total:  record.total_days, consecutive: record.consecutive_days, alreadyDone: true };
  }

  const lastDate = new Date(record.last_logbo_date + 'T00:00:00Z');
  const todayDate = new Date(today + 'T00:00:00Z');
  const diffDays = Math.floor((todayDate - lastDate) / (1000 * 60 * 60 * 24));

  if (diffDays === 1) {
    const newTotal = record.total_days + 1;
    const newConsecutive = record.consecutive_days + 1;
    db.prepare('UPDATE logbo_records SET username = ?, total_days = ?, consecutive_days = ?, last_logbo_date = ? WHERE user_id = ?')
      .run(fullAcct, newTotal, newConsecutive, today, userId);
    return { total: newTotal, consecutive:  newConsecutive, alreadyDone: false };
  } else {
    const newTotal = record.total_days + 1;
    db.prepare('UPDATE logbo_records SET username = ?, total_days = ?, consecutive_days = 1, last_logbo_date = ? WHERE user_id = ? ')
      .run(fullAcct, newTotal, today, userId);
    return { total: newTotal, consecutive: 1, alreadyDone: false };
  }
}

// ãƒ©ãƒ³ã‚­ãƒ³ã‚°å–å¾—
function getRanking() {
  const ranking = db.prepare(`
    SELECT username, consecutive_days, total_days 
    FROM logbo_records 
    ORDER BY consecutive_days DESC, total_days DESC 
    LIMIT 10
  `).all();
  
  if (ranking.length === 0) {
    return 'ç¾åœ¨ã€ãƒ­ã‚°ã‚¤ãƒ³ãƒœãƒ¼ãƒŠã‚¹ã®ãƒ‡ãƒ¼ã‚¿ã¯ã”ã–ã„ã¾ã›ã‚“ã€‚';
  }
  
  let rankingText = 'ğŸ“Š **é€£ç¶šãƒ­ã‚°ã‚¤ãƒ³ãƒœãƒ¼ãƒŠã‚¹ ãƒ©ãƒ³ã‚­ãƒ³ã‚° TOP 10**\n\n';
  ranking.forEach((record, index) => {
    const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : `${index + 1}.  `;
    rankingText += `${medal} \`${record.username}\`\n`; 
    rankingText += `   é€£ç¶š:  ${record.consecutive_days}æ—¥ / åˆè¨ˆ: ${record.total_days}æ—¥\n\n`;
  });
  
  return rankingText;
}

// å…±é€šå‡¦ç†é–¢æ•°
async function processLogboWithAcct(note, userId, acct) {
  const isFollowerUser = await isFollower(userId);

  if (! isFollowerUser) {
    await cli.request('notes/create', {
      text: `@${acct} ãƒ­ã‚°ã‚¤ãƒ³ãƒœãƒ¼ãƒŠã‚¹ã‚’å—ã‘å–ã‚‹ã«ã¯ã€ç§ã‚’ãƒ•ã‚©ãƒ­ãƒ¼ã—ã¦ãã ã•ã„ã€‚ã€Œfollow meã€ã¨é€ã£ã¦ã„ãŸã ã‘ã‚Œã°ãƒ•ã‚©ãƒ­ãƒ¼ã„ãŸã—ã¾ã™ã€‚`,
      replyId: note.id,
      visibility: note.visibility === 'specified' ? 'specified' : 'public'
    });
    return;
  }

  const result = recordLogbo(userId, acct);

  const reactionEmoji = result.alreadyDone ? 'âŒ' : 'â­•';
  await cli.request('notes/reactions/create', {
    noteId: note.id,
    reaction: reactionEmoji,
  });

  const replyVisibility = note.visibility === 'specified' ? 'specified' :  'public';
  let message = '';
  
  if (result. alreadyDone) {
    message = `@${acct} æœ¬æ—¥ã¯æ—¢ã«ãƒ­ã‚°ã‚¤ãƒ³ãƒœãƒ¼ãƒŠã‚¹ã‚’å—å–æ¸ˆã¿ã§ã™ã€‚\né€£ç¶š:  ${result.consecutive}æ—¥ / åˆè¨ˆ: ${result.total}æ—¥`;
  } else {
    message = result.consecutive === 1 && result.total === 1
      ? `@${acct} ğŸ‰ åˆå›ãƒ­ã‚°ã‚¤ãƒ³ãƒœãƒ¼ãƒŠã‚¹ã§ã™ï¼æ˜æ—¥ã‚‚ã¾ãŸãŠè¶Šã—ãã ã•ã„ã€‚`
      : `@${acct} ğŸ ãƒ­ã‚°ã‚¤ãƒ³ãƒœãƒ¼ãƒŠã‚¹ï¼\né€£ç¶šãƒ­ã‚°ã‚¤ãƒ³: ${result.consecutive}æ—¥ç›®\nåˆè¨ˆ:  ${result.total}æ—¥`;
  }

  await cli.request('notes/create', {
    text: message,
    replyId: note.id,
    visibility: replyVisibility
  });
}

// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
function getFullAcct(user) {
  const host = user.host || BOT_HOST; 

// ã‚ã„ã‚“
mainChannel.on('mention', async (note) => {
  console.log('=== Mention event fired ===');
  
  try {
    const text = note.text || '';
    const userId = note. userId;

    console.log(`DEBUG: text = "${text}"`);
    console.log(`DEBUG: userId = ${userId}`);
    console.log(`DEBUG: botUserId = ${botUserId}`);
    console.log(`DEBUG: text.includes('ãƒ©ãƒ³ã‚­ãƒ³ã‚°') = ${text.includes('ãƒ©ãƒ³ã‚­ãƒ³ã‚°')}`);

    if (userId === botUserId) {
      console.log('Skipped: self mention');
      return;
    }

    const acct = getFullAcct(note.user);
    console.log(`Mention received from @${acct}:  ${text}`);

    // follow meå‡¦ç†
    if (text.includes('follow me') || text.includes('ãƒ•ã‚©ãƒ­ãƒ¼ã—ã¦')) {
      console.log('>>> Executing:  follow me');
      await followUser(userId);
      await cli.request('notes/create', {
        text:  `@${acct} ãƒ•ã‚©ãƒ­ãƒ¼ã„ãŸã—ã¾ã—ãŸã€‚ã€Œãƒ­ã‚°ãƒœã€ã¨å‘Ÿã„ã¦ãƒ­ã‚°ã‚¤ãƒ³ãƒœãƒ¼ãƒŠã‚¹ã‚’ãŠå—ã‘å–ã‚Šãã ã•ã„ã€‚`,
        replyId: note. id,
        visibility: note. visibility === 'specified' ? 'specified' : 'public'
      });
      console.log('>>> Completed: follow me');
      return;
    }

    // ãƒ©ãƒ³ã‚­ãƒ³ã‚°å‡¦ç†
    if (text.includes('ãƒ©ãƒ³ã‚­ãƒ³ã‚°')) {
      console.log('>>> Executing: ãƒ©ãƒ³ã‚­ãƒ³ã‚°');
      const rankingText = getRanking();
      console.log(`>>> Ranking text (${rankingText.length} chars): ${rankingText.substring(0, 100)}...`);
      
      const response = await cli.request('notes/create', {
        text:  `@${acct}\n${rankingText}`,
        replyId: note.id,
        visibility: note.visibility === 'specified' ? 'specified' : 'public'
      });
      console.log('>>> Completed: ãƒ©ãƒ³ã‚­ãƒ³ã‚°', response);
      return;
    }

    // ãƒ­ã‚°ãƒœå‡¦ç†
    if (text.includes('ãƒ­ã‚°ãƒœ')) {
      console.log('>>> Executing: ãƒ­ã‚°ãƒœ');
      await processLogboWithAcct(note, userId, acct);
      console.log('>>> Completed: ãƒ­ã‚°ãƒœ');
      return;
    }

    console. log('WARNING: No command matched');

  } catch (error) {
    console.error('! !! ERROR in mainChannel.on(mention):', error);
    console.error('! !! Stack:', error.stack);
  }
});

// ãƒ›ãƒ¼ãƒ ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ç›£è¦–
const homeChannel = stream. useChannel('homeTimeline');

homeChannel.on('note', async (note) => {
  const text = note.text || '';
  const userId = note. userId;

  if (userId === botUserId) return;


  const acct = getFullAcct(note.user);

  // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹å ´åˆã®å‡¦ç†
  if (note. mentions && note.mentions.includes(botUserId)) {
    // ãƒ©ãƒ³ã‚­ãƒ³ã‚°å‡¦ç†ï¼ˆmainChannelã§æ‹¾ãˆãªã‹ã£ãŸå ´åˆã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼‰
    if (text.includes('ãƒ©ãƒ³ã‚­ãƒ³ã‚°')) {
      const rankingText = getRanking();
      await cli.request('notes/create', {
        text: `@${acct}\n${rankingText}`,
        replyId: note.id,
        visibility: note.visibility === 'specified' ? 'specified' :  'public'
      });
      return;
    }

    // follow meå‡¦ç†ï¼ˆmainChannelã§æ‹¾ãˆãªã‹ã£ãŸå ´åˆã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼‰
    if (text.includes('follow me') || text.includes('ãƒ•ã‚©ãƒ­ãƒ¼ã—ã¦')) {
      await followUser(userId);
      await cli.request('notes/create', {
        text: `@${acct} ãƒ•ã‚©ãƒ­ãƒ¼ã„ãŸã—ã¾ã—ãŸã€‚ã€Œãƒ­ã‚°ãƒœã€ã¨å‘Ÿã„ã¦ãƒ­ã‚°ã‚¤ãƒ³ãƒœãƒ¼ãƒŠã‚¹ã‚’ãŠå—ã‘å–ã‚Šãã ã•ã„ã€‚`,
        replyId: note.id,
        visibility: note.visibility === 'specified' ?  'specified' : 'public'
      });
      return;
    }

    // ãƒ­ã‚°ãƒœå‡¦ç†
    if (text.includes('ãƒ­ã‚°ãƒœ')) {
      await processLogboWithAcct(note, userId, acct);
      return;
    }

    // ãã®ä»–ã®ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã¯ç„¡è¦–ï¼ˆmainChannelã§å‡¦ç†æ¸ˆï¼‰
    return;
  }

  if (text.includes('ãƒ­ã‚°ãƒœ')) {
    await processLogboWithAcct(note, userId, acct);
  }
});

console.log('Logbo bot started (without dotenv).');
console.log(`Bot Hostname: ${BOT_HOST}`);
